(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{428:function(a,t,s){"use strict";s.r(t);var e=s(12),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"_1-命令简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令简介"}},[a._v("#")]),a._v(" 1.命令简介")]),a._v(" "),t("p",[a._v("grep（Globally search a Regular Expression and Print）打印匹配模式的行。")]),a._v(" "),t("p",[a._v("grep 支持正则表达式，其功能是在给定的文件中查找一个指定格式或内容的字符串，并将匹配的字符串所在行打印出来。如果不指定任何文件或给定的文件名为连字符 -，则从标准输入设备读取文本，然后在这些文本中进行查找。")]),a._v(" "),t("p",[a._v("grep 家族包括 grep、egrep 和 fgrep，egrep 等同于 grep -E，fgrep 等同于 grep -F。 egrep 或 fgrep 的直接调用已被弃用，但提供这些调用是为了允许依赖它们的历史应用程序未经修改地运行。")]),a._v(" "),t("h2",{attrs:{id:"_2-命令格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[a._v("#")]),a._v(" 2.命令格式")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("OPTION"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" PATTERNS "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("FILE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("OPTION"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-e")]),a._v(" PATTERN "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(". "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("FILE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("OPTION"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-f")]),a._v(" PATTERN_FILE "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(". "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("FILE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),t("h2",{attrs:{id:"_3-选项说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-选项说明"}},[a._v("#")]),a._v(" 3.选项说明")]),a._v(" "),t("p",[a._v("注意，长选项的参数对于短选项也是必须的。")]),a._v(" "),t("h3",{attrs:{id:"通用程序信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通用程序信息"}},[a._v("#")]),a._v(" 通用程序信息")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--help")]),a._v("\n\t显示帮助信息并退出。\n-V, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--version")]),a._v("\n\t显示版本信息并退出。\n")])])]),t("h3",{attrs:{id:"模式语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式语法"}},[a._v("#")]),a._v(" 模式语法")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-E,--extended-regexp\n\t使用扩展正则表达式解释匹配模式。\n-F, --fixed-strings\n\t将匹配模式看作固定字符串而不是正则表达式。\n-G, --basic-regexp\n\t使用基本正则表达式解释匹配模式。这是缺省的。\n-P, --perl-regexp\n\t将模式解释为 perl 兼容的正则表达式"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("PCRE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("。这是实验性的，grep "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-P")]),a._v(" 可能会警告未实现的特性。\n")])])]),t("h3",{attrs:{id:"匹配控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匹配控制"}},[a._v("#")]),a._v(" 匹配控制")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-e, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--regexp")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("PATTERN\n\t匹配模式。如果使用此选项多次或与 -f（--file）选项组合使用，搜索给定的所有模式。此选项可用于保护以 “-” 开头的模式\n-f, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--file")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("FILE\n\t将匹配模式写在文件中，文件中一行内容对应一个匹配模式\n-i, --ignore-case\n\t忽略字符大小写\n-v, --invert-match\n\t反向选择，显示不包含匹配文本的所有行\n-w, --word-regexp\n\t整个单词匹配才算匹配\n-x, --line-regexp\n\t整行匹配才算匹配\n"),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-y")]),a._v("\n\t过时的 "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-i")]),a._v(" 同义词\n")])])]),t("h3",{attrs:{id:"一般输出控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一般输出控制"}},[a._v("#")]),a._v(" 一般输出控制")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-c, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--count")]),a._v("\n\t只输出匹配的行数，不是匹配字符串的个数\n--color, --colour"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("WHEN"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\t将找到的关键词加上颜色显示。WHEN 可取值 never、always 或 auto\n-L, --files-without-match\n\t不输出包含匹配模式文件的文件名\n-l, --files-with-matches\n\t只输出包含匹配模式文件的文件名\n-o, --only-matching\n\t只显示匹配的字符串，并以单独行输出。\n-q, --quiet, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--silent")]),a._v("\n\t静默模式，不显示任何信息到标准输出\n-s, --no-messages\n\t不显示不存在或无匹配文本的错误信息\n")])])]),t("h3",{attrs:{id:"输出行前缀控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输出行前缀控制"}},[a._v("#")]),a._v(" 输出行前缀控制")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-b, --byte-offset\n\t在匹配的行之前，标示出该行第一个字符的位编号，即字符在文本中的字节偏移下标，包括换行符\n-H, --with-filename\n\t查询多文件时显示文件名（默认选项）\n-h, --no-filename\n\t查询多文件时不显示文件名\n-n, --line-number\n\t显示匹配行及行号\n-T, --initial-tab\n\t使用 Tab 使匹配行对齐\n-u, --unix-byte-offsets\n\t以 Unix 样式进行字节偏移。使用该选项，使 "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" 产生的结果与在 Unix 机器上相同，此选项必须与 "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-b")]),a._v(" 同时使用，否则没有效果，也必须要在 MS-DOS 和 MS-Windows 平台上使用\n-Z, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--null")]),a._v("\n\t文件名与匹配行之间使用空字符。grep 默认会在每个输出前打印文件名，文件名与匹配行之间会有一个冒号隔开，-Z选项告诉grep不要使用冒号了，使用一个NUL字符\n")])])]),t("h3",{attrs:{id:"上下行控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上下行控制"}},[a._v("#")]),a._v(" 上下行控制")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-A, --after-context"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("NUM\n\t后紧跟数字，为 after 之意。除了列出匹配字符串所在行之外，后续的 NUM 行也列出来\n-B, --before-context"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("NUM\n\t后紧跟数字，为 before 之意，显示匹配行以及该行之前指定行数的内容\n-, -C, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--context")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("NUM\n\t显示匹配行以及该行上下指定行数的内容\n")])])]),t("h3",{attrs:{id:"文件与目录选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件与目录选择"}},[a._v("#")]),a._v(" 文件与目录选择")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("-a, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--text")]),a._v("\n\t将 binary 文件以 text 文件的方式处理，等同于 --binary-files"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("text 选项。\n-D, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--devices")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("ACTION\n\t如果输入文件是设备，命名管道（FIFO）或套接字，则使用指定动作处理它。默认情况下，为读取操作（read），这意味着读取设备就像它们是普通文件。如果操作是跳过（skip），设备将被悄悄跳过。\n-d, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--directories")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("ACTION\n\t当指定要查找的是目录而非文件时，使用指定的操作处理。动作有：read（默认）像普通文件一样读取目录；skip：忽略指定目录；recurse：递归读取指定目录下的所有文件，此操作等同于-r选项。\n"),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-I")]),a._v("\n\t忽略二进制文件。等同于 --binary-files"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("without-match\n-R, -r, "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--recursive")]),a._v("\n\t递归搜索给定目录下的所有文件。等价于 "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-d")]),a._v(" recurse。\n")])])]),t("h2",{attrs:{id:"_4-正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-正则表达式"}},[a._v("#")]),a._v(" 4.正则表达式")]),a._v(" "),t("p",[a._v("正则表达式是描述一组字符串的模式。正则表达式的构造类似于算术表达式，通过使用各种运算符组合较小的表达式。")]),a._v(" "),t("p",[a._v("grep 理解三种不同版本的正则表达式语法：")]),a._v(" "),t("ul",[t("li",[a._v("basic regular expression (BRE)")]),a._v(" "),t("li",[a._v("extended regular expression (ERE)")]),a._v(" "),t("li",[a._v("perl compatible regular expression (PCRE)")])]),a._v(" "),t("p",[a._v("在 GNU grep 中，基本语法和扩展语法在可用功能上没有区别。在其他实现中，基本正则表达式就没有那么强大了。")]),a._v(" "),t("p",[a._v("在基本正则表达式中，元字符"),t("code",[a._v("? + { | ( )")]),a._v("失去了它们的特殊含义，需要使用反斜杠版本"),t("code",[a._v("\\? \\+ \\{ \\| \\( \\)")]),a._v("。")]),a._v(" "),t("p",[a._v("传统的 egrep 不支持 { 元字符，一些 egrep 实现支持 {，因此可移植脚本应该避免在 grep -E 模式中使用 {，应该使用 [{] 来匹配文字 {。")]),a._v(" "),t("p",[a._v("GNU "),t("code",[a._v("grep -E")]),a._v("试图支持传统用法，假设 { 是一个无效的间隔规范的开始，那么它就不是特殊的。例如，命令"),t("code",[a._v("grep -E '{1'")]),a._v("搜索\n对于两个字符的字符串"),t("code",[a._v("{1")]),a._v("，而不是在正则表达式中报告语法错误。POSIX 允许这种行为作为扩展，但是可移植脚本应该避免这种情况。")]),a._v(" "),t("p",[a._v("Perl 正则表达式提供了额外的功能，并在 "),t("a",{attrs:{href:"https://man7.org/linux/man-pages/man3/pcresyntax.3.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("pcresyntax(3)"),t("OutboundLink")],1),a._v(" 和 "),t("a",{attrs:{href:"https://man7.org/linux/man-pages/man3/pcrepattern.3.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("pcrepattern(3)"),t("OutboundLink")],1),a._v(" 中有文档说明，但可能不是在每个系统上都可用。")]),a._v(" "),t("h2",{attrs:{id:"_5-常用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-常用示例"}},[a._v("#")]),a._v(" 5.常用示例")]),a._v(" "),t("p",[a._v("（1）统计字段出现的次数。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-o")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("pattern"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("finename"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("wc")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-l")]),a._v("\n")])])]),t("p",[a._v("选项 -o 只显示匹配的字符串，并以单独行输出。")]),a._v(" "),t("p",[a._v("wc -l 统计输入的行数。就可以知道这个要统计的字段出现的次数了。")]),a._v(" "),t("p",[a._v("假如有一个文件 txt 内容如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Hi my name is Bob.\n")])])]),t("p",[a._v("如果想统计字母 m 出现的次数，那么用下面的命令可以实现。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-o")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"m"')]),a._v(" txt "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("wc")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-l")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v("\n")])])]),t("p",[a._v("（2）搜索指定范围的数字。比如查询包含 540-600 的行。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'5[4-9][0-9]\\|600'")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("filename"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 或")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-E")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'5[4-9][0-9]|600'")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("filename"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),t("p",[a._v("之所以竖杠 | 需要加上反斜杠进行转义，是因为竖杠 | 在 Shell 中是特殊字符，表示管道命令。可以使用 "),t("code",[a._v("-E")]),a._v(" 选项显示指明为正则表达式，那么就不需要对竖杠 | 进行转义。")]),a._v(" "),t("p",[a._v("（3）递归搜索当前目录下的所有文件。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-r")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"lvlv"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),a._v("\n")])])]),t("p",[a._v("（4）显示所有以 d 开头的文件中包含test的行。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'test'")]),a._v(" d*\n")])])]),t("p",[a._v("（5）打印在 aa，bb，cc 文件中匹配 test 的行，并显示行号。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-n")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'test'")]),a._v(" aa bb cc\n")])])]),t("p",[a._v("（6）打印 aa 中包含有至少 5 个连续小写字符的字符串的所有行。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'[a-z]\\{5\\}'")]),a._v(" aa\n")])])]),t("p",[a._v("这里必须使用双引号或者单引号将查找 pattern 包围。")]),a._v(" "),t("p",[a._v("单引号与双引号的区别主要有：")]),a._v(" "),t("ul",[t("li",[a._v("单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。")]),a._v(" "),t("li",[a._v("双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量的内容。一般常量用单引号括起，如果含有变量则用双引号括起来。但是也有意外，比如查找特殊字符反斜杠使用："),t("code",[a._v("grep '\\' ./*")]),a._v("则会报"),t("code",[a._v("grep: Trailing backslash")]),a._v("错误，需要使用"),t("code",[a._v("grep '\\\\' ./*")]),a._v("才可以。")])]),a._v(" "),t("p",[a._v("（7）统计文件中含有指定字符串的行数。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" aaa "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("file")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("wc")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-l")]),a._v("\n")])])]),t("p",[a._v("grep 可用于 Shell 脚本，因为 grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2。我们利用这些返回值就可进行一些自动化的文本处理工作。")]),a._v(" "),t("p",[a._v("（8）使用多个条件的或查询。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 方法一：使用符号 |。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern1\\|pattern2"')]),a._v(" filename\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 方法二：使用 -E 选项，用扩展正则表达式解释匹配模式。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-E")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern1|pattern2"')]),a._v(" filename\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 方法三：使用 -e 选项指定多个匹配模式。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-E")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-e")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern1"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-e")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern2"')]),a._v(" filename\n")])])]),t("p",[a._v("在方法三中，可以使用 -e 选项来指定多个模式，这些模式之间的关系是或的关系。与此同时，还指定了 -E 选项，表示对模式的解释采用扩展正则表达式。")]),a._v(" "),t("p",[a._v("（9）使用多个条件的与查询。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 使用管道命令")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern1"')]),a._v("  filename "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("grep")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pattern2"')]),a._v("\n")])])]),t("hr"),a._v(" "),t("h2",{attrs:{id:"参考文献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[a._v("#")]),a._v(" 参考文献")]),a._v(" "),t("p",[t("a",{attrs:{href:"http://man7.org/linux/man-pages/man1/grep.1.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("grep(1) - Linux manual page - man7.org"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"http://blog.csdn.net/u010009623/article/details/52117828",target:"_blank",rel:"noopener noreferrer"}},[a._v("Linux知其然且知所以然之grep命令"),t("OutboundLink")],1)]),a._v(" "),t("Vssue",{attrs:{title:"grep"}})],1)}),[],!1,null,null,null);t.default=r.exports}}]);