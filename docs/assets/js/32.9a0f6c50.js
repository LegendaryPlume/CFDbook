(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{362:function(t,n,a){"use strict";a.r(n);var e=a(12),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"_1-功能简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-功能简介"}},[t._v("#")]),t._v(" 1.功能简介")]),t._v(" "),n("p",[t._v("objdump 是 "),n("a",{attrs:{href:"https://www.gnu.org/software/binutils/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GNU Binutils"),n("OutboundLink")],1),t._v(" 二进制工具集的一员，用于查看目标文件或可执行文件的组成信息，以可读的形式打印二进制文件的内容。")]),t._v(" "),n("h2",{attrs:{id:"_2-命令格式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[t._v("#")]),t._v(" 2.命令格式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("objdump [OPTIONS] OBJFILES\n")])])]),n("h2",{attrs:{id:"_3-选项说明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-选项说明"}},[t._v("#")]),t._v(" 3.选项说明")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("-a, --archive-headers\n\t显示档案头信息，展示档案每一个成员的文件格式。效果等同于命令 ar -tv\n-b, --target=BFDNAME\n\t指定目标码格式。这不是必须的，objdump 能自动识别许多格式，比如 objdump -b oasys -m vax -h fu.o 显示 fu.o 的头部摘要信息，明确指出该文件是 Vax 系统下用 Oasys 编译器生成的目标文件。objdump -i 将给出这里可以指定的目标码格式列表\n-C, --demangle[=STYLE]\n\t目标文件中的符号解码成用户级名称。比如移除符号修饰时在变量与函数名前添加的下划线等。\n-d, --disassemble\n\t反汇编目标文件，将机器指令反汇编成汇编代码\n-D, --disassemble-all\n\t与 -d 类似，但反汇编所有段（section）\n-z, --disassemble-zeroes\n\t一般反汇编输出将省略零块，该选项使得这些零块也被反汇编 \n-EB, -EL,--endian={big | little}\n\t指定目标文件的字节序，在目标文件没描述字节序时很有用，例如 S-records。这个选项只影响反汇编\n-f, --file-headers\n\t显示每一个目标文件的头信息\n-F, --file-offsets\n\t反汇编时，打印每一个符号的偏移地址\n--file-start-context\n\t显示源码/汇编代码（假设为 -S）时，将上下文扩展到文件的开头\n-g, --debugging\n\t显示调试信息。企图解析保存在文件中的调试信息并以 C 语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持\n-e, --debugging-tags\n\t类似 -g 选项，但是生成的信息是和ctags工具相兼容的格式\n-h, --section-headers, --headers\n\t显示目标文件各个 section 的头部摘要信息\n-i, --info\n\t显示对于 -b 或者 -m 选项可用的架构和目标格式列表\n-j, --section=NAME\n\t仅显示指定名称的 section 的信息 \n-l, --line-numbers\n\t用文件名和行号标注相应的目标代码，仅仅和 -d、-D 或者 -r 一起使用\n-S,--source\n\t反汇编时尽可能使用源代码表示。隐含了-d参数\n-m, --architecture=MACHINE\n\t指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构\n-M, --disassembler-options=OPTIONS\n\t给反汇编程序传递参数，可以指定多个，使用逗号分隔\n-p, --private-headers\n\t打印目标文件格式的特定信息。打印的信息取决于目标文件格式，对于某些目标文件格式，不打印任何附加信息。\n-P, --private=OPTIONS\n\t打印目标文件格式的特定信息。OPTIONS 是一个逗号分隔的列表。例如对于XCOFF，可用的选项有 header, aout, sections, syms, relocs, lineno, loader, except, typchk, traceback and toc\n-r, --reloc\n\t显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来\n-R, --dynamic-reloc\n\t显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库\n-s, --full-contents\n\t显示section的完整内容。默认所有的非空section都会被显示\n-W[lLiaprmfFsoRt],--dwarf=[rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index]\n\t显示文件中调试段的内容，如果存在的话\n-G, --stabs\n\t显示请求的任何 section 的全部内容。显示段 .stab、.stab.index 和 .stab.excl 的内容\n-t, --syms\n\t显示文件的符号表入口。类似于nm -s提供的信息\n-T, --dynamic-syms\n\t显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D,--dynamic 显示的信息\n-x, --all-headers\n\t显示所可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -p -r -t 同时指定\n-w, --wide\n\t为具有超过80列的输出设备格式化某些行。也不要在显示符号名称时截断符号名称\n--start-address=ADDRESS\n\t从指定地址开始显示数据，该选项影响 -d、-r 和 -s 选项的输出\n--stop-address=ADDRESS\n\t显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出\n--prefix-addresses\n\t反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式\n--no-show-raw-insn\n\t反汇编时，不显示汇编指令的机器码。当使用--prefix-addresses时，这是缺省选项\n--adjust-vma=OFFSET\n\t当解析信息时，首先给所有的段添加偏移值offset。当段地址与符号表不符时，这个选项很有用。比如将段放置到特殊地址，因为某个格式无法表示段地址，比如 a.out\n--special-syms\n\t显示特殊符号与用户不关心的符号\n--prefix=PREFIX\n\t当使用 -S 时，指定前缀添加到绝对路径中\n--prefix-strip=LEVEL\n\t指定剥离绝对路径中多少个前缀目录名。此选项只有在使用了选项 --prefix=PREFIX 才有效\n--insn-width=WIDTH\n\t指定反汇编后的指令输出的行宽，单位字节\n-V, --version\n\t版本信息\n-H, --help\n\t帮助信息\n")])])]),n("h2",{attrs:{id:"_4-常用示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-常用示例"}},[t._v("#")]),t._v(" 4.常用示例")]),t._v(" "),n("p",[t._v("首先给出后面大部分测试所基于的源代码以及编译指令。 涉及两个 C++ 源文件。\nobjdump.cpp：")]),t._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        std"),n("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"objdump"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("std"),n("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("main.cpp：")]),t._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("使用-g选项加入调试信息，分别编译生成目标文件objdump.o与main.o。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("g++ -c -g objdump.cpp -o objdump.o\ng++ -c -g main.cpp -o main.o\n")])])]),n("p",[t._v("然后通过ar命令将两个目标文件打包成静态库libobjdump.a。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ar crv libobjdump.a main.o objdump.o\n")])])]),n("p",[t._v("（1）查看档案包含的目标文件列表。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# objdump -a libobjdump.a\nIn archive libobjdump.a:\n\nmain.o:     file format elf64-x86-64\nrw-r--r-- 0/0  18696 Mar  8 20:25 2019 main.o\n\nobjdump.o:     file format elf64-x86-64\nrw-r--r-- 0/0  21352 Mar  8 20:25 2019 objdump.o\n")])])]),n("p",[t._v("使用命令ar -tv也可以列出档案中包含的目标文件。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# ar -tv libobjdump.a\nrw-r--r-- 0/0  18696 Mar  8 20:25 2019 main.o\nrw-r--r-- 0/0  21352 Mar  8 20:25 2019 objdump.o\n")])])]),n("p",[t._v("（2）显示目标文件objdump.o的代码段（.text）内容。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# objdump --section=.text  -s objdump.o\nobjdump.o:     file format elf64-x86-64\n\nContents of section .text:\n 0000 554889e5 be000000 00bf0000 0000e800  UH..............\n 0010 000000be 00000000 4889c7e8 00000000  ........H.......\n 0020 5dc35548 89e54883 ec10897d fc8975f8  ].UH..H....}..u.\n 0030 837dfc01 7527817d f8ffff00 00751ebf  .}..u'.}.....u..\n 0040 00000000 e8000000 00ba0000 0000be00  ................\n 0050 000000bf 00000000 e8000000 00c9c355  ...............U\n 0060 4889e5be ffff0000 bf010000 00e8b0ff  H...............\n 0070 ffff5dc3                             ..].\n")])])]),n("p",[t._v("注意，不能单独使用-j或者--section选项，一定要加上-s选项。")]),t._v(" "),n("p",[t._v("（3）反汇编objdump.o中的text段内容，并尽可能用源代码形式表示。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('[root@TENCENT64 ~]# objdump --section=.text -S objdump.o\nobjdump.o:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 <_Z5printv>:\n#include <iostream>\n\nvoid print()\n{\n   0:\t55                   \tpush   %rbp\n   1:\t48 89 e5             \tmov    %rsp,%rbp\n\tstd::cout<<"objdump"<<std::endl;\n   4:\tbe 00 00 00 00       \tmov    $0x0,%esi\n   9:\tbf 00 00 00 00       \tmov    $0x0,%edi\n   e:\te8 00 00 00 00       \tcallq  13 <_Z5printv+0x13>\n  13:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  18:\t48 89 c7             \tmov    %rax,%rdi\n  1b:\te8 00 00 00 00       \tcallq  20 <_Z5printv+0x20>\n}\n  20:\t5d                   \tpop    %rbp\n  21:\tc3                   \tretq   \n\n0000000000000022 <_Z41__static_initialization_and_destruction_0ii>:\n  22:\t55                   \tpush   %rbp\n  23:\t48 89 e5             \tmov    %rsp,%rbp\n  26:\t48 83 ec 10          \tsub    $0x10,%rsp\n  2a:\t89 7d fc             \tmov    %edi,-0x4(%rbp)\n  2d:\t89 75 f8             \tmov    %esi,-0x8(%rbp)\n  30:\t83 7d fc 01          \tcmpl   $0x1,-0x4(%rbp)\n  34:\t75 27                \tjne    5d <_Z41__static_initialization_and_destruction_0ii+0x3b>\n  36:\t81 7d f8 ff ff 00 00 \tcmpl   $0xffff,-0x8(%rbp)\n  3d:\t75 1e                \tjne    5d <_Z41__static_initialization_and_destruction_0ii+0x3b>\n  extern wostream wclog;\t/// Linked to standard error (buffered)\n#endif\n  //@}\n\n  // For construction of filebuffers for cout, cin, cerr, clog et. al.\n  static ios_base::Init __ioinit;\n  3f:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  44:\te8 00 00 00 00       \tcallq  49 <_Z41__static_initialization_and_destruction_0ii+0x27>\n  49:\tba 00 00 00 00       \tmov    $0x0,%edx\n  4e:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  53:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  58:\te8 00 00 00 00       \tcallq  5d <_Z41__static_initialization_and_destruction_0ii+0x3b>\n  5d:\tc9                   \tleaveq \n  5e:\tc3                   \tretq   \n\n000000000000005f <_GLOBAL__sub_I__Z5printv>:\n  5f:\t55                   \tpush   %rbp\n  60:\t48 89 e5             \tmov    %rsp,%rbp\n  63:\tbe ff ff 00 00       \tmov    $0xffff,%esi\n  68:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  6d:\te8 b0 ff ff ff       \tcallq  22 <_Z41__static_initialization_and_destruction_0ii>\n  72:\t5d                   \tpop    %rbp\n  73:\tc3                   \tretq\n')])])]),n("p",[t._v("（3）显示目标文件的符号表入口。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# objdump -t objdump.o\nobjdump.o:     file format elf64-x86-64\n\nSYMBOL TABLE:\n0000000000000000 l    df *ABS*\t0000000000000000 objdump.cpp\n0000000000000000 l    d  .text\t0000000000000000 .text\n0000000000000000 l    d  .data\t0000000000000000 .data\n0000000000000000 l    d  .bss\t0000000000000000 .bss\n0000000000000000 l     O .bss\t0000000000000001 _ZStL8__ioinit\n0000000000000000 l    d  .rodata\t0000000000000000 .rodata\n0000000000000022 l     F .text\t000000000000003d _Z41__static_initialization_and_destruction_0ii\n000000000000005f l     F .text\t0000000000000015 _GLOBAL__sub_I__Z5printv\n0000000000000000 l    d  .init_array\t0000000000000000 .init_array\n0000000000000000 l    d  .debug_info\t0000000000000000 .debug_info\n0000000000000000 l    d  .debug_abbrev\t0000000000000000 .debug_abbrev\n0000000000000000 l    d  .debug_aranges\t0000000000000000 .debug_aranges\n0000000000000000 l    d  .debug_line\t0000000000000000 .debug_line\n0000000000000000 l    d  .debug_str\t0000000000000000 .debug_str\n0000000000000000 l    d  .note.GNU-stack\t0000000000000000 .note.GNU-stack\n0000000000000000 l    d  .eh_frame\t0000000000000000 .eh_frame\n0000000000000000 l    d  .comment\t0000000000000000 .comment\n0000000000000000 g     F .text\t0000000000000022 _Z5printv\n0000000000000000         *UND*\t0000000000000000 _ZSt4cout\n0000000000000000         *UND*\t0000000000000000 _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n0000000000000000         *UND*\t0000000000000000 _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_\n0000000000000000         *UND*\t0000000000000000 _ZNSolsEPFRSoS_E\n0000000000000000         *UND*\t0000000000000000 _ZNSt8ios_base4InitC1Ev\n0000000000000000         *UND*\t0000000000000000 .hidden __dso_handle\n0000000000000000         *UND*\t0000000000000000 _ZNSt8ios_base4InitD1Ev\n0000000000000000         *UND*\t0000000000000000 __cxa_atexit\n")])])]),n("p",[t._v("这里，输出的信息类似nm -s命令的输出，相比较之下，nm命令的输出如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# nm -s objdump.o\n                 U __cxa_atexit\n                 U __dso_handle\n000000000000005f t _GLOBAL__sub_I__Z5printv\n0000000000000022 t _Z41__static_initialization_and_destruction_0ii\n0000000000000000 T _Z5printv\n                 U _ZNSolsEPFRSoS_E\n                 U _ZNSt8ios_base4InitC1Ev\n                 U _ZNSt8ios_base4InitD1Ev\n                 U _ZSt4cout\n                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_\n0000000000000000 b _ZStL8__ioinit\n                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n")])])]),n("p",[t._v("（4）显示目标文件各个段的头部摘要信息。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[root@TENCENT64 ~]# objdump -h objdump.o\nobjdump.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000074  0000000000000000  0000000000000000  00000040  2**2\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000000  0000000000000000  0000000000000000  000000b4  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000001  0000000000000000  0000000000000000  000000b4  2**2\n                  ALLOC\n  3 .rodata       00000008  0000000000000000  0000000000000000  000000b4  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .init_array   00000008  0000000000000000  0000000000000000  000000c0  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, DATA\n  5 .debug_info   000014f9  0000000000000000  0000000000000000  000000c8  2**0\n                  CONTENTS, RELOC, READONLY, DEBUGGING\n  6 .debug_abbrev 0000039f  0000000000000000  0000000000000000  000015c1  2**0\n                  CONTENTS, READONLY, DEBUGGING\n  7 .debug_aranges 00000030  0000000000000000  0000000000000000  00001960  2**0\n                  CONTENTS, RELOC, READONLY, DEBUGGING\n  8 .debug_line   00000244  0000000000000000  0000000000000000  00001990  2**0\n                  CONTENTS, RELOC, READONLY, DEBUGGING\n  9 .debug_str    00000e4c  0000000000000000  0000000000000000  00001bd4  2**0\n                  CONTENTS, READONLY, DEBUGGING\n 10 .comment      0000002d  0000000000000000  0000000000000000  00002a20  2**0\n                  CONTENTS, READONLY\n 11 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00002a4d  2**0\n                  CONTENTS, READONLY\n 12 .eh_frame     00000078  0000000000000000  0000000000000000  00002a50  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n")])])]),n("hr"),t._v(" "),n("h2",{attrs:{id:"参考文献"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.gnu.org/software/binutils/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GNU Binutils"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://man7.org/linux/man-pages/man1/objdump.1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("objdump(1) - Linux manual page - man7.org"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"http://man.linuxde.net/objdump",target:"_blank",rel:"noopener noreferrer"}},[t._v("objdump命令.Linux命令大全"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=s.exports}}]);