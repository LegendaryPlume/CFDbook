(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{436:function(t,e,n){"use strict";n.r(e);var s=n(10),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-命令简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令简介"}},[t._v("#")]),t._v(" 1.命令简介")]),t._v(" "),e("p",[t._v("systemctl 是管理操作系统和服务的命令，是与 systemd 交互的主要工具，其实现的功能包含了 service 和 chkconfig 这两个命令的功能。")]),t._v(" "),e("p",[t._v("systemd（system daemon）是操作系统的服务管理器，用于取代 system V 和 BSD 风格的 init 程序，是一号进程，掌管整个系统的其他进程，用于集中管理和配置类 UNIX 系统。每个服务都有一个启动文件，描述 systemd 应该如何启动自己。")]),t._v(" "),e("h2",{attrs:{id:"_2-命令格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[t._v("#")]),t._v(" 2.命令格式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl [OPTIONS...] COMMAND [NAME...]\n")])])]),e("h2",{attrs:{id:"_3-选项说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-选项说明"}},[t._v("#")]),t._v(" 3.选项说明")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("-t, --type=[help, UNITTYPE...]\n\t指明单元类型，使用逗号分隔。如果是 help，则列出所有可用的 unit type\n--state=UNITSTATE...\n\t指明单元的状态，使用逗号分隔。例如使用 --state=failed，则在输出单元列表时只展示状态为 failed 的单元\n-p, --property=PROPERTY...\n\t使用 show 命令显示 unit/job/manager 属性时，将显示限制为参数中指定的属性，使用逗号分隔，例如属性 MainPID\n-a, --all\n\t列出单元时，显示所有加载的单元，无论其状态如何，包括非活动单元。显示 unit/job/manager 属性时，显示所有属性，无论它们是否已设置\n-r, --recursive\n\t列出单元时，还显示本地容器的单元。本地容器的单元将以容器名称作为前缀，并用单个冒号字符分隔\n--reverse\n\t与命令 list-dependencies 一起使用，显示单元之间的反向依赖项\n--after\n\t与命令 list-dependencies 一起使用，显示指定单元前面的单元\n--before\n\t与命令 list-dependencies 一起使用，显示指定单元后面的单元\n-l, --full\n\t不要省略单元名称、进程树条目、日志输出，也不要截断状态、单元列表、作业列表和计时器列表输出中的单元描述\n--show-types\n\t显示套接字时，显示套接字的类型\n--job-mode=MODE\n\t在对新作业排队时，此选项控制如何处理已排队的作业。可取值 fail、replace、replace_irreversibly、isolate、ignore-dependencies、ignore-requirements 或 flush 之一。默认为 replace，除非使用了表示隔离作业模式的 isolate 命令\n-i, --ignore-inhibitors\n\t当系统关闭或睡眠请求时，忽略约束锁，否则系统关闭或睡眠请求会失败。应用程序可以建立约束锁，以避免某些重要操作（如CD刻录或类似操作）被系统关闭或睡眠状态中断\n-q, --quiet\n\t静默模式，抑制 snapshot, is-active, is-failed, is-enabled, is-system-running, enable 和 disable 命令的标准输出\n--no-block\n\t不同步等待请求的操作完成。如果未指定该选项，验证完作业并排队，systemctl 将等待作业完成\n--system\n\t与服务管理器（service manager）交互。为缺省选项\n--no-wall\n\t在 halt, power-off, reboot 操作前不发出警告\n--no-reload\n\t当与命令 enable 和 disable 一起使用时，不隐式重新加载守护程序的配置\n--no-ask-password\n\t当与 start 和相关命令一起使用时，禁止请求密码\n--kill-who=WHO\n\t与命令 kill 一起使用时，选择向哪个进程发送信号。必须是 main、control 或 all 中的一个，分别选择杀死主进程、控制进程还是单元的所有进程\n-s, --signal=SIGNAL\n\t与命令 kill 一起使用，选择向进程发送的信号。缺省为 SIGTERM\n-f, --force\n\t与 enable 一起使用时，覆盖任何现有冲突的符号链接。与 halt、poweroff、reboot 或 kexec 一起使用时，在不关闭所有单元的情况下执行所选操作\n--now\n\t当与 enable 一起使用时，单元也将启动。当与 disable 或 mask 一起使用时，单元也将停止\n--root=PATH\n\t当与 enable/disable/is-enabled（等相关命令）一起使用时，在查找单元文件时使用指定的根路径\n--runtime\n\t当与 enable、disable、edit（等相关命令）一起使用时，只需临时进行更改，以便在下次系统重新启动时丢失这些更改\n--preset-mode=MODE\n\t与命令 preset 或 preset-all 一起使用时，预设模式为 full（缺省）、enable-only 或 disable-only 三者之一\n-n, --lines=NUM\n\t与命令 status 一起使用时，控制日志文件显示的行数。默认为 10\n-o, --output=FORMAT\n\t与命令 status 一起使用时，控制日志条目的显示格式，默认为 short。其它取值可参考命令 journalctl(1)。\n--plain\n\t当与命令 list-dependencies 一起使用时，输出将打印为列表而不是树。\n-H, --host=HOST\n\t指定远程主机名，或用户名@主机名进行远程操作。机名可以选择用一个容器名作为后缀，用 : 分隔\n-M, --machine=MACHINE\n\t指定本地容器名\n--no-pager\n\t不将管道输出送到分页浏览工具\n--no-legend\n\t不打印列头和列脚\n-h, --help\n\t显示帮助信息并退出\n--version\n\t显示版本信息并退出\n")])])]),e("h2",{attrs:{id:"_4-命令说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-命令说明"}},[t._v("#")]),t._v(" 4.命令说明")]),t._v(" "),e("p",[t._v("实际上 systemctl 子命令的使用频率会比选项更加频繁，主要有")]),t._v(" "),e("ul",[e("li",[t._v("单元命令（Unit Commands）")]),t._v(" "),e("li",[t._v("单元文件命令（Unit File Commands）")]),t._v(" "),e("li",[t._v("容器命令（Machine Commands）")]),t._v(" "),e("li",[t._v("作业命令（Job Commands）")]),t._v(" "),e("li",[t._v("快照命令（Snapshot Commands）")]),t._v(" "),e("li",[t._v("环境命令（Environment Commands）")]),t._v(" "),e("li",[t._v("管理器生命周期命令（Manager Lifecycle Commands）")]),t._v(" "),e("li",[t._v("系统命令（System Commands）")])]),t._v(" "),e("h3",{attrs:{id:"_4-1-单元命令-unit-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-单元命令-unit-commands"}},[t._v("#")]),t._v(" 4.1 单元命令（Unit Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list-units [PATTERN...]\n\t列出所有已启动的单元。如果指定一个或多个匹配模式，则只显示符合某个模式的单元。该命令为默认命令\nlist-sockets [PATTERN...]\n\t列出套接字单元，按照监听的地址排列输出。如果指定一个或多个匹配模式，则只显示符合某个模式的单元\nlist-timers [PATTERN...]\n\t列出按时间顺序排列的计时器单元。如果指定一个或多个匹配模式，则只显示符合某个模式的单元\nstart PATTERN...\n\t启动指定的单元\nstop PATTERN...\n\t停止指定的单元\nreload PATTERN...\n\t重新加载指定单元服务的配置文件。注意，是重新加载服务的配置，而不是 systemd 的单元配置文件。如果希望 systemd 重新加载单元的配置文件，请使用 daemon-reload 命令。换句话说：对于 Apache 的示例，这将在 web 服务器中重新加载 Apache 的 httpd.conf，而不是 apache.service systemd 单元文件\nrestart PATTERN...\n\t重启指定的单元\ntry-restart PATTERN...\n\t尝试重启指定的单元。如果单元不处于运行状态，则不进行重启\nreload-or-restart PATTERN...\n\t重新加载指定单元服务的配置文件。如果失败则重启服务\nreload-or-try-restart PATTERN...\n\t重新加载指定单元服务的配置文件。如果失败则尝试重启服务。如果单元不处于运行状态，则不进行重启\nisolate NAME\n\t启动命令行中指定的单元及其依赖项，并停止所有其他的单元\nkill PATTERN...\n\t向单元的一个或多个进程发送信号。使用 --kill who= 选择要终止的进程。使用 --signal= 选择要发送的信号\nis-active PATTERN...\n\t检查指定单元是否处于 active 状态。如果至少一个是活动的，则返回退出代码 0，否则为非零\nis-failed PATTERN...\n\t检查指定单元是否处于 failed 状态。如果至少一个是失败的，则返回退出代码 0，否则为非零\nstatus [PATTERN...|PID...]\n\t显示一个或多个单元的简要运行时状态信息，然后是日志中的最新日志数据。如果未指定单位，则显示系统状态。如果与 --all 结合使用，还将显示所有单元的状态。如果给定 PID，则显示进程所属单元的信息\nshow [PATTERN...|JOB...]\n\t显示一个或多个单元、作业或管理器本身的属性。如果未指定参数，则将显示管理器的属性\ncat PATTERN...\n\t显示一个或多个单元的配置文件\nset-property NAME ASSIGNMENT...\n\t在运行时设置指定的单元属性。如果同时使用 --runtime 选项，则下一次系统重启属性将失效\nhelp PATTERN...|PID...\n\t显示一个或多个单元的手册页（如果可用）。如果给定了PID，则显示该进程所属单元的手册页\nreset-failed [PATTERN...]\n\t重置指定单元的 failed 状态，如果未指定单元名称，则重置所有单元的 failed 状态\nlist-dependencies [NAME]\n\t显示指定单元所依赖的单元。它递归地列出 Requires=、RequiresOverridable=、Requisite=、RequisiteOverridable=、Wants=、BindsTo= 依赖项之后的单元。如果未指定单位，缺省为 default.target\n")])])]),e("h3",{attrs:{id:"_4-2-单元文件命令-unit-file-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-单元文件命令-unit-file-commands"}},[t._v("#")]),t._v(" 4.2 单元文件命令（Unit File Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list-unit-files [PATTERN...]\n\t列出已安装的单元文件及其启用状态\nenable NAME...\n\t启用一个或多个单元文件或单元文件实例。这将创建一些符号链接，记录在单元文件的 Install 部分。创建符号链接后，将重新加载 systemd 配置以确保立即生效\ndisable NAME...\n\t禁用一个或多个单元。这将从单元配置目录中删除指向指定单元文件的所有符号链接，从而撤消由 enable 所做的更改。移除符号链接后，将重新加载 systemd 配置以确保立即生效。注意，此命令不会隐式停止正在禁用的单元。如果需要的话，使用 --now 选项，要么在之后执行一个附加的 stop 命令\nreenable NAME...\n\t重新启用一个或多个单元文件。这是 disable 和 enable 的组合，用于将启用单元的符号链接重置为单元文件 Install 部分中配置的值\npreset NAME...\n\t重置指定单元文件的 disable/enable 状态为预设策略文件中配置的值。可以与选项 --preset-mode 联用选择重置的结果状态。关于预设策略格式的详细信息，参见 systemd.preset(5)\npreset-all\n\t将所有已安装的单元文件重置为预设策略文件中配置的默认值。可以与选项 --preset-mode 联用选择重置的结果状态\nis-enabled NAME...\n\t检查是否启用了指定的单元文件\nmask NAME...\n\t屏蔽一个或多个单元文件，把这些单元链接到 /dev/null，使它们无法启动\nunmask NAME...\n\t反屏蔽一个或多个单元文件\nlink FILENAME...\n\t将不在单元文件搜索路径中的单元文件链接到单元文件搜索路径中，这需要单元文件的绝对路径\nadd-wants TARGET NAME..., add-requires TARGET NAME...\n\t给指定单元添加依赖\nedit NAME...\n\t编辑插入片段或使用选项 --full 表示替换整个文件，以扩展或重写指定的单元\nget-default\n\t返回别名为 default.target 的单元\nset-default NAME\n\t设置默认的单元，使 default.target 软链接到目标单元\n")])])]),e("h3",{attrs:{id:"_4-3-容器命令-machine-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-容器命令-machine-commands"}},[t._v("#")]),t._v(" 4.3 容器命令（Machine Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list-machines [PATTERN...]\n\t列出主机和所有正在运行的本地容器及其状态。如果指定了一个或多个模式，则只显示与其中一个模式匹配的容器\n")])])]),e("h3",{attrs:{id:"_4-4-作业命令-job-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-作业命令-job-commands"}},[t._v("#")]),t._v(" 4.4 作业命令（Job Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list-jobs [PATTERN...]\n\t\ncancel JOB...\n\t列出正在进行的作业。如果指定了一个或多个模式，则只显示与其中一个模式匹配的单元的作业\ncancel JOB...\n\t取消一个或多个指定作业 ID 的作业。如果未指定作业 ID，则取消所有挂起的作业\n")])])]),e("h3",{attrs:{id:"_4-5-快照命令-snapshot-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-快照命令-snapshot-commands"}},[t._v("#")]),t._v(" 4.5 快照命令（Snapshot Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("snapshot [NAME]\n\t创建指定名称的快照。如果未指定快照名则自动生成。快照指的是 systemd 管理器的保存状态。它被实现为一个使用此命令动态生成的单元，并且依赖于当时活动的所有单元。稍后，用户可以使用快照单元上的 isolate 命令返回到该状态\ndelete PATTERN...\n\t删除快照\n")])])]),e("h3",{attrs:{id:"_4-6-环境命令-environment-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-环境命令-environment-commands"}},[t._v("#")]),t._v(" 4.6 环境命令（Environment Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("show-environment\n\t显示 systemd manager 使用的环境变量\nset-environment VARIABLE=VALUE...\n\t设置 systemd manager 使用的环境变量\nunset-environment VARIABLE...\n\t取消一个或多个 systemd manager 的环境变量\nimport-environment [VARIABLE...]\n\t将客户端上设置的一个或多个环境变量导入 systemd manager 环境块。如果未传递参数，则导入整个环境块\n")])])]),e("h3",{attrs:{id:"_4-7-管理器生命周期命令-manager-lifecycle-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-管理器生命周期命令-manager-lifecycle-commands"}},[t._v("#")]),t._v(" 4.7 管理器生命周期命令（Manager Lifecycle Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("daemon-reload\n\t重新加载 systemd 管理器配置。这将重新运行所有生成器（请参阅 systemd.generator（7）），重新加载所有单元文件，并重新创建整个依赖关系树。在重新加载守护进程时，所有 systemd 监听的代表用户配置的 sockets，保持可访问状态\ndaemon-reexec\n\t重新执行 systemd 管理器\n")])])]),e("h3",{attrs:{id:"_4-8-系统命令-system-commands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-系统命令-system-commands"}},[t._v("#")]),t._v(" 4.8 系统命令（System Commands）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("is-system-running\n\t检查系统是否正在运并返回当前的系统状态，状态有 initializing，starting，running，degraded，maintenance，stopping\ndefault\n\t进入默认模式，等同于子命令 isolate default.target\nrescue\n\t进入救援模式。等同于子命令 isolate rescue.target，会向所有用户打印警告消息\nemergency\n\t进入紧急模式。等同于子命令 isolate emergency.target，会向所有用户打警告消息\nhalt\n\t关闭并停止系统。等同于子命令 start halt.target --irreversible\npoweroff\n\t关闭并关闭系统电源。等同于子命令 start poweroff.target --irreversible，会向所有用户打印警告消息\nreboot [arg]\n\t关闭并重新启动系统。等同于子命令 start reboot.target --irreversible，会向所有用户打印警告消息\nkexec\n\t通过 kexec 关闭并重新启动系统。等同于子命令 start kexec.target --irreversible，会向所有用户打印警告消息\nswitch-root ROOT [INIT]\n\t切换到不同的根目录并在其下执行新的系统管理器进程\nsuspend\n\t暂停系统\nhibernate\n\t使系统休眠。这将激活特殊的 hibernate.target 目标\nhybrid-sleep\n\t休眠并挂起系统。这将激活特殊的 hybrid-sleep.target 目标\n")])])]),e("p",[t._v("实际上，systemctl 常用的子命令并不多，主要有：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("start\t启动服务\nstop\t停止服务\nrestart\t重启服务\nenable\t使某服务开机自启\ndisable\t关闭某服务开机自启\nstatus\t查看服务状态\nlist-units -–type=service 列举所有已启动服务\n")])])]),e("h2",{attrs:{id:"_5-常用示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-常用示例"}},[t._v("#")]),t._v(" 5.常用示例")]),t._v(" "),e("p",[t._v("（1）使用 systemctl 管理系统。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 重启系统\nsystemctl reboot\n\n# 关闭系统，切断电源\nsystemctl poweroff\n\n# CPU停止工作\nsystemctl halt\n\n# 暂停系统\nsystemctl suspend\n\n# 让系统进入冬眠状态\nsystemctl hibernate\n\n# 让系统进入交互式休眠状态\nsystemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\nsystemctl rescue\n")])])]),e("p",[t._v("（2）使用 systemctl list-units 查看系统的单元。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 列出正在运行的 unit\nsystemctl\n# 或\nsystemctl list-units\n\n# 列出所有 unit，包括没有运行的 unit\nsystemctl list-units --all\n\n# 列出所有没有运行的 unit\nsystemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 unit\nsystemctl list-units --failed\n\n# 列出所有正在运行类型为 service 的 unit\nsystemctl list-units --type=service\n")])])]),e("p",[t._v("（3）使用 systemctl status 查看系统状态和单个 unit 的状态。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 显示系统状态\nsystemctl status\n\n# 显示单个 unit 的状态\nsystemctl status apache.service\n\n# 显示远程主机的某个 unit 的状态\nsystemctl -H root@rhel7.example.com status httpd.service\n")])])]),e("p",[t._v("（4）服务管理。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 启动一个服务\nsystemctl start apache.service\n\n# 停止一个服务\nsystemctl stop apache.service\n\n# 重启一个服务\nsystemctl restart apache.service\n\n# 杀死一个服务的所有子进程\nsystemctl kill apache.service\n\n# 重新加载一个服务的配置文件\nsystemctl reload apache.service\n\n# 重新加载 systemd 管理器配置\nsystemctl daemon-reload\n\n# 显示某个 unit 的所有底层参数\nsystemctl show httpd.service\n\n# 显示某个 unit 的指定属性的值\nsystemctl show -p CPUShares httpd.service\n\n# 设置某个 unit 的指定属性\nsystemctl set-property httpd.service CPUShares=500\n")])])]),e("p",[t._v("（5）查看 unit 之间的依赖关系。\nA 依赖于 B，意味着 systemd 在启动 A 的时候，同时会去启动 B。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 列出一个 Unit 的所有依赖\n$ systemctl list-dependencies nginx.service\n")])])]),e("p",[t._v("上面命令的输出结果之中，有些依赖是 Target 类型，默认不会展开显示。如果要展开 Target，就需要使用 --all 参数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl list-dependencies --all nginx.service\n")])])]),e("p",[t._v("（6）设置服务开机启动。\nsystemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。systemctl enable命令用于在上面两个目录之间，建立符号链接关系。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl enable sshd.service\n# 等同于\nln -s /usr/lib/systemd/system/sshd.service /etc/systemd/system/multi-user.target.wants/sshd.service'\n")])])]),e("p",[t._v("如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。与之对应的，systemctl disable 命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl disable sshd.service\n")])])]),e("p",[t._v("配置文件的后缀名，就是该 unit 的种类，比如 sshd.socket。如果省略，systemd 默认后缀名为 .service，所以 sshd 会被理解成 sshd.service。")]),t._v(" "),e("h2",{attrs:{id:"_6-拓展知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-拓展知识"}},[t._v("#")]),t._v(" 6.拓展知识")]),t._v(" "),e("h3",{attrs:{id:"_6-1-unit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-unit"}},[t._v("#")]),t._v(" 6.1 Unit")]),t._v(" "),e("h4",{attrs:{id:"_6-1-1-配置文件的格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-1-配置文件的格式"}},[t._v("#")]),t._v(" 6.1.1 配置文件的格式")]),t._v(" "),e("p",[t._v("systemd 可以管理所有系统资源，不同的资源统称为单元（unit）。unit 一共分成 12 种。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Service unit：系统服务\nTarget unit：多个 Unit 构成的一个组\nDevice Unit：硬件设备\nMount Unit：文件系统的挂载点\nAutomount Unit：自动挂载点\nPath Unit：文件或路径\nScope Unit：不是由 Systemd 启动的外部进程\nSlice Unit：进程组\nSnapshot Unit：Systemd 快照，可以切回某个快照\nSocket Unit：进程间通信的 socket\nSwap Unit：swap 文件\nTimer Unit：定时器\n")])])]),e("p",[t._v("每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。配置文件就是普通的文本文件，可以用文本编辑器打开，也可以使用 systemctl cat 命令查看配置文件的内容。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl cat sshd.service\n\n# /usr/lib/systemd/system/sshd.service\n[Unit]\nDescription=OpenSSH server daemon\nDocumentation=man:sshd(8) man:sshd_config(5)\nAfter=network.target sshd-keygen.service\nWants=sshd-keygen.service\n\n[Service]\nEnvironmentFile=/etc/sysconfig/sshd\nExecStart=/usr/sbin/sshd -D $OPTIONS\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=process\nRestart=on-failure\nRestartSec=42s\n\n[Install]\nWantedBy=multi-user.target\n")])])]),e("p",[t._v("从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。每个区块内部是一些等号连接的键值对。注意，键值对的等号两侧不能有空格。")]),t._v(" "),e("h4",{attrs:{id:"_6-1-2-配置文件的区块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-2-配置文件的区块"}},[t._v("#")]),t._v(" 6.1.2 配置文件的区块")]),t._v(" "),e("p",[t._v("[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Description：简短描述\nDocumentation：文档地址\nRequires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败\nWants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败\nBindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\nBefore：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动\nAfter：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动\nConflicts：这里指定的 Unit 不能与当前 Unit 同时运行\nCondition...：当前 Unit 运行必须满足的条件，否则不会运行\nAssert...：当前 Unit 运行必须满足的条件，否则会报启动失败\n")])])]),e("p",[t._v("[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Type：定义启动时的进程行为。它有以下几种值。\nType=simple：默认值，执行ExecStart指定的命令，启动主进程\nType=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\nType=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\nType=dbus：当前服务通过D-Bus启动\nType=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\nType=idle：若有其他任务执行完毕，当前服务才会运行\nExecStart：启动当前服务的命令\nExecStartPre：启动当前服务之前执行的命令\nExecStartPost：启动当前服务之后执行的命令\nExecReload：重启当前服务时执行的命令\nExecStop：停止当前服务时执行的命令\nExecStopPost：停止当其服务之后执行的命令\nRestartSec：自动重启当前服务间隔的秒数\nRestart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\nTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数\nEnvironment：指定环境变量\n")])])]),e("p",[t._v("[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中\nRequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中\nAlias：当前 Unit 可用于启动的别名\nAlso：当前 Unit 激活（enable）时，会被同时激活的其他 Unit\n")])])]),e("h4",{attrs:{id:"_6-1-3-配置文件的状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-3-配置文件的状态"}},[t._v("#")]),t._v(" 6.1.3 配置文件的状态")]),t._v(" "),e("p",[t._v("systemctl list-unit-files 命令用于列出所有配置文件。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 列出所有配置文件\n$ systemctl list-unit-files\n\n# 列出指定类型的配置文件\n$ systemctl list-unit-files --type=service\n")])])]),e("p",[t._v("这个命令会输出一个列表。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl list-unit-files\n\nUNIT FILE              STATE\nchronyd.service        enabled\nclamd@.service         static\nclamd@scan.service     disabled\n")])])]),e("p",[t._v("这个列表显示每个配置文件的状态，一共有四种。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("enabled：已建立启动链接\ndisabled：没建立启动链接\nstatic：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖\nmasked：该配置文件被禁止建立启动链接\n")])])]),e("p",[t._v("注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的 systemctl status 命令。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl status sshd.service\n")])])]),e("p",[t._v("一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemctl daemon-reload\nsystemctl restart httpd.service\n")])])]),e("h3",{attrs:{id:"_6-2-target"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-target"}},[t._v("#")]),t._v(" 6.2 Target")]),t._v(" "),e("p",[t._v("启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。")]),t._v(" "),e("p",[t._v('简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于"状态点"，启动某个 Target 就好比启动到某种状态。')]),t._v(" "),e("p",[t._v("传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 查看当前系统的所有 Target\nsystemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\nsystemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\nsystemctl get-default\n\n# 设置启动时的默认 Target\nsystemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程\nsystemctl isolate multi-user.target\n")])])]),e("p",[t._v("Target 与 传统 RunLevel 的对应关系如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Traditional runlevel      New target name     Symbolically linked to...\n\nRunlevel 0           |    runlevel0.target -> poweroff.target\nRunlevel 1           |    runlevel1.target -> rescue.target\nRunlevel 2           |    runlevel2.target -> multi-user.target\nRunlevel 3           |    runlevel3.target -> multi-user.target\nRunlevel 4           |    runlevel4.target -> multi-user.target\nRunlevel 5           |    runlevel5.target -> graphical.target\nRunlevel 6           |    runlevel6.target -> reboot.target\n")])])]),e("p",[t._v("它与init进程的主要差别如下。")]),t._v(" "),e("p",[t._v("（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到 graphical.target（图形界面）或者multi-user.target（多用户命令行）。")]),t._v(" "),e("p",[t._v("（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。")]),t._v(" "),e("p",[t._v("（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。")]),t._v(" "),e("h3",{attrs:{id:"_6-3-日志管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-日志管理"}},[t._v("#")]),t._v(" 6.3 日志管理")]),t._v(" "),e("p",[t._v("Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf。")]),t._v(" "),e("p",[t._v("journalctl 功能强大，用法非常多。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 查看所有日志（默认情况下，只保存本次启动的日志）\njournalctl\n\n# 查看内核日志（不显示应用日志）\njournalctl -k\n\n# 查看系统本次启动的日志\njournalctl -b\njournalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\njournalctl -b -1\n\n# 查看指定时间的日志\njournalctl --since="2012-10-30 18:17:16"\njournalctl --since "20 min ago"\njournalctl --since yesterday\njournalctl --since "2015-01-10" --until "2015-01-11 03:00"\njournalctl --since 09:00 --until "1 hour ago"\n\n# 显示尾部的最新10行日志\njournalctl -n\n\n# 显示尾部指定行数的日志\njournalctl -n 20\n\n# 实时滚动显示最新日志\njournalctl -f\n\n# 查看指定服务的日志\njournalctl /usr/lib/systemd/systemd\n\n# 查看指定进程的日志\njournalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\njournalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\njournalctl -u nginx.service\njournalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\njournalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有 8 级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n\njournalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\njournalctl --no-pager\n\n# 以 JSON 格式（单行）输出\njournalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\njournalctl -b -u nginx.serviceqq -o json-pretty\n\n# 显示日志占据的硬盘空间\njournalctl --disk-usage\n\n# 指定日志文件占据的最大空间\njournalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\njournalctl --vacuum-time=1years\n')])])]),e("hr"),t._v(" "),e("h2",{attrs:{id:"参考文献"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://man7.org/linux/man-pages/man1/systemctl.1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("systemctl(1) - Linux manual page - man7.org"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_37766296/article/details/80192633",target:"_blank",rel:"noopener noreferrer"}},[t._v("最简明扼要的 Systemd 教程，只需十分钟"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/dengjin20104042056/article/details/99698356",target:"_blank",rel:"noopener noreferrer"}},[t._v("【Linux】一步一步学Linux——systemctl命令(147)"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰的网络日志Systemd 入门教程：命令篇"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);