{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{304:function(t,n,a){\"use strict\";a.r(n);var s=a(10),e=Object(s.a)({},(function(){var t=this,n=t._self._c;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h2\",{attrs:{id:\"_1-命令简介\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-命令简介\"}},[t._v(\"#\")]),t._v(\" 1.命令简介\")]),t._v(\" \"),n(\"p\",[t._v(\"nm（names） 是 \"),n(\"a\",{attrs:{href:\"https://www.gnu.org/software/binutils/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"GNU Binutils\"),n(\"OutboundLink\")],1),t._v(\" 二进制工具集的一员，用于显示目标文件中的符号。\")]),t._v(\" \"),n(\"p\",[t._v(\"如果没有为 nm 命令指明目标文件，缺省目标文件是 a.out。\")]),t._v(\" \"),n(\"p\",[t._v(\"nm 命令显示的符号类型，至少使用以下类型，其他类型取决于目标文件格式。符号类型如果是小写，符号通常是本地的；如果是大写，符号是全局的（外部的）。但是，有一些小写符号类型表示特殊的全局符号，例如 u、v 和 w。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"A\\n该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。\\n\\nb,B\\n该符号的值出现在非初始化数据段（BSS）中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在BSS段中的偏移。\\n\\nC\\n该符号为common。common symbol是未初始化的数据。该符号没有包含在一个普通section中，只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个C文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C，否则其类型为B。\\n\\nd,D\\n该符号位于初始化数据段（data section）。例如定义全局变量 int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会被分配在初始化数据段中。\\n\\ng,G\\n该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式\\n\\ni\\n这是对标准ELF符号类型集的GNU扩展。它表示一个符号如果被重定位引用，不会计算该符号的地址，而是必须在运行时计算\\n\\nN\\n该符号是一个debugging符号。\\n\\np\\n该符号在stack unwind section\\n\\nr,R\\n该符号位于只读数据段（read only data section）。例如定义全局const int test[] = {123, 123};则test就是一个只读数据段的符号。\\n\\ns,S\\n符号位于非初始化数据区，用于small object。\\n\\nt,T\\n该符号位于代码段（text section）。\\n\\nu\\n符号是唯一的全局符号。这是GNU对标准ELF符号绑定集的扩展。对于这样的符号，动态链接器将确保在整个过程中只有一个使用此名称和类型的符号。\\n\\nU\\n该符号在当前文件中是未定义的，即该符号定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，这个被调用的函数在当前文件就是未定义的，但是在定义它的文件中类型是T。对于全局变量来说，在定义它的文件中，其符号类型为B或D，在使用它的文件中，其类型为U。\\n\\nv,V\\n该符号是一个弱符号。当弱定义符号与正常定义符号链接时，使用正常定义符号时不会出错。当链接未定义的弱定义符号，弱符号的值将变为零，且没有错误。在某些系统上，大写表示已指定默认值\\n\\nw,W\\n该符号是一个弱符号，未专门标记为弱对象符号。当弱定义符号与正常定义符号链接时，使用正常定义符号时不会出错。当链接未定义的弱未定义符号时，该符号的值将以系统特定的方式确定，且不会出错。在某些系统上，大写表示已指定默认值\\n\\n-\\n该符号是a.out格式文件中的stabs symbol。在这种情况下，打印的下一个值是stabs other字段、stabs desc字段和stab类型。stabs符号用于保存调试信息\\n\\n?\\n该符号类型没有定义\\n\")])])]),n(\"h2\",{attrs:{id:\"_2-命令格式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-命令格式\"}},[t._v(\"#\")]),t._v(\" 2.命令格式\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"nm [-A|-o|--print-file-name] [-a|--debug-syms]\\n   [-B|--format=bsd] [-C|--demangle[=style]]\\n   [-D|--dynamic] [-f<format>|--format=<format>]\\n   [-g|--extern-only] [-h|--help]\\n   [-l|--line-numbers] [-n|-v|--numeric-sort]\\n   [-P|--portability] [-p|--no-sort]\\n   [-r|--reverse-sort] [-S|--print-size]\\n   [-s|--print-armap] [-t <radix>|--radix=<radix>]\\n   [-u|--undefined-only] [-V|--version]\\n   [-X 32_64] [--defined-only] [--no-demangle]\\n   [--plugin <name>] [--size-sort] [--special-syms]\\n   [--synthetic] [--target=bfdname]\\n   [objfile...]\\n\")])])]),n(\"h2\",{attrs:{id:\"_3-选项说明\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-选项说明\"}},[t._v(\"#\")]),t._v(\" 3.选项说明\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"-A, -o, --print-file-name\\n\\t在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次\\n-a, --debug-syms\\n\\t显示调试符号\\n-B, --format=bsd\\n\\t用来兼容 MIPS 的 nm\\n-C, --demangle[=STYLE]\\n\\t将低级符号名解码（demangle）成用户级名字，比如去除编译时添加的前置下划线，这样可以使得 C++ 函数名具有可读性。不同的编译器符号修饰风格不同，可以使用 =STYLE 参数来选择合适的解码风格\\n-D, --dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义\\n-f, --format=FORMAT\\n\\tFORMAT 可取值 bsd、sysv 或 posix，该选项在 GNU nm 中有用，默认为 bsd\\n-g, --extern-only\\n\\t仅显示外部符号\\n-h, --help\\n\\t显示帮助信息\\n-l, --line-numbers\\n\\t对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后\\n-n, -v, --numeric-sort\\n\\t按符号对应地址的顺序排序，而非按符号名的字符顺序\\n-P, --portability\\n\\t使用 POSIX.2 标准输出格式代替默认的输出格式。等同于 -f posix\\n-p, --no-sort\\n\\t按目标文件中遇到的符号顺序显示，不排序\\n-r, --reverse-sort\\n\\t逆序排序。例如，升序变为降序\\n-S, --print-size\\n\\t以 BSD 输出样式输出已定义符号的值和大小。对于不记录符号大小的目标文件格式，此选项不起作用，除非使用了--size sort，在这种情况下，将显示计算的大小\\n-s, --print-armap\\n\\t当列出库中成员的符号时，同时列出索引。索引的内容包含：模块与其包含的名字的定义之间的映射\\n-t, --radix=RADIX\\n\\t使用基数 radix 进制显示符号值。radix 只能为 d（十进制）、o（八进制）或 x（十六进制）\\n-u, --undefined-only\\n\\t仅显示没有定义的符号\\n-V, --version\\n\\t显示版本信息并退出\\n-X\\n\\t为了与 AIX 版本的 nm 兼容，选项 -X 将被忽略。它可接受一个参数，该参数必须是字符串32_64。AIX nm 的默认模式对应于 -X 32，GNU nm 不支持模式 -X 32\\n--defined-only\\n\\t仅显示有定义的符号\\n--no-demangle\\n\\t不解码低级符号名，这是默认选项\\n--plugin NAME\\n\\t加载名为 name 的插件以添加对额外目标类型的支持。只有在启用插件支持的情况下构建了工具链时，此选项才可用\\n--size-sort\\n\\t按符号大小排列\\n--special-syms\\n\\t显示目标相关的具体特殊含义的符号。这些符号通常被特定目标文件用于某些特殊处理，当包含在正常符号列表中时通常不起作用。例如，对于ARM目标，此选项将跳过用于标记ARM代码、Thumb代码和数据之间转换的映射符号\\n--synthetic\\n\\t输出合成符号。合成符号是链接器为各种目的创建的特殊符号，默认情况下不会显示它们，因为它们不是二进制文件源代码的一部分\\n--target=BFDNAME\\n\\t指定系统默认格式以外的目标文件格式\\n\")])])]),n(\"h2\",{attrs:{id:\"_4-常用示例\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-常用示例\"}},[t._v(\"#\")]),t._v(\" 4.常用示例\")]),t._v(\" \"),n(\"p\",[t._v(\"首先给出后面大部分示例所基于的源代码以及编译指令。 涉及两个 C++ 源文件。\\ntest.cpp：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-cpp extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-cpp\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token macro property\"}},[n(\"span\",{pre:!0,attrs:{class:\"token directive-hash\"}},[t._v(\"#\")]),n(\"span\",{pre:!0,attrs:{class:\"token directive keyword\"}},[t._v(\"include\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"<iostream>\")])]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" dUnInitialized\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" dInitialized \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"char\")]),t._v(\" sTest\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"good\"')]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"print\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        std\"),n(\"span\",{pre:!0,attrs:{class:\"token double-colon punctuation\"}},[t._v(\"::\")]),t._v(\"cout\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"dUnInitialized=\"')]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),t._v(\"dUnInitialized\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\" dInitialized=\"')]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),t._v(\"dInitialized\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\" sTest=\"')]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),t._v(\"sTest\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<<\")]),t._v(\"std\"),n(\"span\",{pre:!0,attrs:{class:\"token double-colon punctuation\"}},[t._v(\"::\")]),t._v(\"endl\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"p\",[t._v(\"main.cpp：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-cpp extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-cpp\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token macro property\"}},[n(\"span\",{pre:!0,attrs:{class:\"token directive-hash\"}},[t._v(\"#\")]),n(\"span\",{pre:!0,attrs:{class:\"token directive keyword\"}},[t._v(\"include\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v(\"<iostream>\")])]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"using\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"namespace\")]),t._v(\" std\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"print\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"extern\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" dUnInitialized\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"main\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\\t\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" localVar\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"666\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\tdUnInitialized\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\t\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"print\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"p\",[t._v(\"使用-g选项加入调试信息，分别编译生成目标文件objdump.o与main.o。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"g++ -c -g test.cpp -o test.o\\ng++ -c -g main.cpp -o main.o\\n\")])])]),n(\"p\",[t._v(\"然后通过ar命令将两个目标文件打包成静态库libobjdump.a。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"ar crv libnm.a main.o test.o\\n\")])])]),n(\"p\",[t._v(\"（1）列出目标文件 test.o 与 main.o 的符号清单。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"nm -C *.o\\nmain.o:\\n                 U __cxa_atexit\\n                 U __dso_handle\\n                 U dUnInitialized\\n0000000000000057 t _GLOBAL__sub_I_main\\n0000000000000000 T main\\n000000000000001a t __static_initialization_and_destruction_0(int, int)\\n                 U print()\\n                 U std::ios_base::Init::Init()\\n                 U std::ios_base::Init::~Init()\\n0000000000000000 b std::__ioinit\\n\\ntest.o:\\n                 U __cxa_atexit\\n0000000000000000 D dInitialized\\n                 U __dso_handle\\n0000000000000000 B dUnInitialized\\n00000000000000ae t _GLOBAL__sub_I_dUnInitialized\\n0000000000000004 D sTest\\n0000000000000071 t __static_initialization_and_destruction_0(int, int)\\n0000000000000000 T print()\\n                 U std::ostream::operator<<(int)\\n                 U std::ostream::operator<<(std::ostream& (*)(std::ostream&))\\n                 U std::ios_base::Init::Init()\\n                 U std::ios_base::Init::~Init()\\n                 U std::cout\\n                 U std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&)\\n0000000000000004 b std::__ioinit\\n                 U std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)\\n\")])])]),n(\"p\",[t._v(\"使用 -C 选项将符号解码成可读形式，从 test.o 的输出结果可以看出，已初始化的全局变量 dInitialized 与 sTest，符号类型是 D，所以其位于初始化的 Data 段。未初始化的全局变量 dUnInitialized 符号类型是 B，所以其位于未初始化的 BSS 段。函数print() 的符号类型是 T，说明其位于代码段（Text Section）。\")]),t._v(\" \"),n(\"p\",[t._v(\"从 main.o 的输出结果可以看出，变量 dUnInitialized 与函数 print() 因为均定义在其它文件中，所以符号类型是 U，表示该符号在当前文件中是未定义的。值得注意的是，变量 localVar 因为是局部变量， nm 无法获取其符号。\")]),t._v(\" \"),n(\"hr\"),t._v(\" \"),n(\"h2\",{attrs:{id:\"参考文献\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考文献\"}},[t._v(\"#\")]),t._v(\" 参考文献\")]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://www.gnu.org/software/binutils/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"GNU Binutils\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://man7.org/linux/man-pages/man1/nm.1.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"nm(1) - Linux manual page - man7.org\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"http://linux.51yip.com/search/nm\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Linux命令手册.nm\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://blog.csdn.net/stpeace/article/details/47089585\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"linux中的nm命令简介\"),n(\"OutboundLink\")],1)])])}),[],!1,null,null,null);n.default=e.exports}}]);","extractedComments":[]}